<html>
	<head>
		<title>The Sonic the Hedgehog 2.0 Hacking Page</title>
	</head>
	<body>
		<p align="center">
			<big><big><b><i>
		The Sonic the Hedgehog 2.0 Hacking Page</big><br>
		... or not having anything better to do than hack yet another remake<br>
		</b></i></big>
		<!-- <img src="scratch.png"><br> -->
		<b><i>Written by nextvolume</b></i><br>
		<font color="#ff0000">Not updated for 1.4, it still 
refers to 1.3</font><br>
		</p>
		
		<p>
			It was unavoidable. Time had come. Yet another re-release; great cash cow by the way!<br>
			That  said, it's Sonic 1, right? It can't be wrong, can it? And most of all, made with the Retro-Engine?<br>
			I <b><u>had to</b></u> look inside it.<br>
			<br>
		</p>
		
		<p align="center">
			<big>Notation</big>
		</p>
		
		<p>
			Here I will describe the notation I will be using throughout the document.<br>
			I will describe every chunk of data as a C structure, and don't worry, you do not really
			need to know C to understand what each field means.<br>
			For example let's say we have a signed 16-bit value referenced as A and an unsigned 32-bit value
			referenced as B inside a block type we references as Simple; in my notation this would be:
		</p>
		
		<p><small>
			<b>struct Simple<br>
			{<br>
			&nbsp;&nbsp;&nbsp;&nbsp;int16_t A; <font color="#007f00"><i>/** Comment 1, for A */</i></font><br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint32_t B;<br> <font color="#007f00"><i>/**<br>&nbsp;&nbsp;&nbsp;&nbsp; Comment 2, for B<br> */<br></i></font><br>
			}<br>
			</b></small>
		</p>
		
		<p>
			Comments come always after the element they refer to.<br>
			I also assume you know what little-endian and big-endian order means.
		</p>
		
		<p>
			<b>How to find the game executable</b>:<br>
			If you have the iPhone version, inside the IPA it is at <b><i>Payload/Sonic 1.app/Sonic 1</b></i><br>
			If you have the Android version, inside the APK it is either at <b><i>lib/armeabi/libsonic1native.so</b></i> or at
			<b><i>lib/armeabi-v7a/libsonic1native.so</b></i>. They're the same but compiled for different CPU versions.<br>
			Can't open IPKs or APKs? Simply rename their extension to ZIP!<br>
		</p>
		
		<p>
			<b>How to find the game datafile</b>:<br>
			If you have the iPhone version, inside the IPA it is at <b><i>Payload/Sonic 1.app/Data.rsdk</b></i><br>
			If you have the Android version, inside the APK it is at <b><i>assets/Data.rsdk.xmf</b></i>
		</p>
		
		<p align="center">
			<big>Datafile format</big>
		</p>
		
		<p>
			The files for Sonic 2.0 are stored entirely within an archive file, called datafile.<br>
			It's like a ZIP or a TAR archive, just in its own custom format.<br>
		</p>
		
		<p>
			Datafile structure<br>
			<b><small>
			struct DataFile<br>
			{<br>
			&nbsp;&nbsp;&nbsp;&nbsp;struct Header header;<br>
			<font color="#007f00"><i>/** Header */</i></font>
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;struct FileDescriptionBlock fblock[header.numberOfFiles];<br>
			<font color="#007f00"><i>/** Sequentially, a file description block for every file stored inside the data file. */</i></font><br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint8_t data[];<br>
			<font color="#007f00"><i>/** Stored file data. */</i></font><br>
			}<br>
			</b></small>
		
		<p>
			Header<br>
			<b><small>
			struct Header<br>
			{<br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint32_t magicNumber;<br>
			<font color="#007f00"><i>/** Magic number. Used for identifying the file as an RSDK datafile. 32-bit little-endian */</i></font>
			<br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint16_t formatVersion;<br>
			<font color="#007f00"><i>/** Usually 'vB' */</i></font><br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint16_t numberOfFiles;<br>
			<font color="#007f00"><i>/** Number of files stored in the datafile. 16-bit little-endian. */</i></font><br>
			}<br>
			</b></small>
		</p>
		
		<p>
			File Description Block<br>
			<b><small>
			struct FileDescriptionBlock<br>
			{<br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint32_t md5[4];<br>
			<font color="#007f00"><i>/** These 32-bit little-endian values are the MD5 key for the file name. See <a href="#md5keys">here</a> for more information */</i></font><br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint32_t dataFileOffset;<br>
			<font color="#007f00"><i>/** Absolute offset in datafile for the file data. Example: if this value is 0xabadec, the file data for the file is found
				starting at offset 0xabadec in this datafile. 32-bit little endian.*/</i></font><br>
			&nbsp;&nbsp;&nbsp;&nbsp;uint32_t fileSize;<br>
			<font color="#007f00"><i>/** File size in bytes. 32-bit little endian. <br>
			The 31th-bit inside this value has a very important purpose - if it is set the file is encrypted.<br>
			If ([this value] AND 0x80000000) == 0x80000000 the file is encrypted.<br>
			To get the real file size value, AND this value with 0x7FFFFFFF */</i></font><br>
			}<br>
			</b></small>
		</p>
		
		<a id="md5keys">
			<b>The MD5 keys and how to compute them</b><br>
			<p>To thwart hacking, the new datafile format uses the following system:<br>
			<ol>
			<li>A path inside the datafile is requested by Retro-Engine SDK</li>
			<li>The path string is converted to lower case</li>
			<li>An MD5 hash is computed from the string</li>
			<li>The datafile reading code iterates through the file description blocks. A match is found if a file is found for which the MD5 key matches.
			If no match is found, there was no file named as such in the datafile.</li>
			</ol>
			  </p>
			  
			  <p>It makes our life more difficult when hacking, because we have no directory structure and do not know the path of a file.<br>
			  But as long as one keeps the original hashes, despite not having the original filename, a new datafile can be created and the data will
			  be found by the game anyway!
			  </p>
		</a>
		
		<p>
			<b>How to access the remastered soundtrack</b>
		</p>
		<p>
			The remastered soundtrack is one of the most advertised features of this remake.<br>
			The good news is that you can extract the soundtrack with Retrun-Sonic and listen to it!<br>
			The music is in the free and open source Ogg Vorbis format. Most common audio players can play the format.<br>
			Sample command line: <b>retrun x Data.rsdk -3 -d=sonic_music</b><br>
			The bin files will then appear in the <i>sonic_music</i> directory.<br>
			If your audio player doesn't want to play the files, rename the extension of the file you want to play to .OGG
		</p>
		
		<p>
			<u>iPhone version:</u>
			Files from <u><i>86.bin</u></i> to <u><i>111.bin</u></i>
		<p>
		
		<p>
			<u>Android version:</u>
			Files from <u><i>88.bin</u></i> to <u><i>113.bin</u></i>
		</p>
		
		<p>
			<b>How to create a datafile with Retrun-Sonic</b>
		</p>
		<p>
			Retrun-Sonic currently supports creating datafiles in Sonic 1 format, and it can also use an hash information file.<br>
			The hash information file allows us to tinker without knowing the original filename requested by the Retro-Engine - MD5 is a one-way hash function.<br>
			There is a line for each file for which additional information is needed, in the following format:<br>
			<small><u>Filename on disk</u> <u>Encryption flag (Always "Dec", kept for backwards compatiblity)</u> <u>MD5 hash</u></small>
		</p>
		<p>
			The following example replaces the Green Hill Zone music with an Ogg Vorbis file supplied by the user:<br>
			retrun x Data.rsdk -3 -P=hash.txt<br>
			[ now replace Data/94.bin with your own Ogg Vorbis file]<br>
			retrun c Data Data.rsdk -3 -P=hash.txt<br>
			<br>
			For the Android version, replace Data/94.bin with Data/96.bin.
		</p>
			<b>Tips for reverse engineering</b>
		</p>
		<p>
			<font color="#ff0000"><u>The datafile format has been fully reverse-engineered. Information here is just for the curious.</u></font><br>
			If you want to help reverse engineering the game and its formats, grab a copy of the IDA Pro Demo <a href="https://www.hex-rays.com/products/ida/support/download_demo.shtml">
			here</a>. If you don't run the operating systems listed there, IDA Pro runs great even under the Wine emulator.<br>
			It is a crippled version, meaning you can't save and you have other serious limits, but for poking at what's inside the executable
			it is great.<br>
			You can reverse-engineer whatever version you have, but if you want to get the most out of your reverse engineering, it is recommended that you
			work on the Android version.<br>
			The reason for this is that more symbol information was preserved in the binary so you actually have many RSDK function
			names at hand!<br>
		</p>
		
		<p>
			<i>Email: tails92@gmail.com</i>
		</p>
		<p align="right">
			Last Updated: May 23rd, 2013<br>
			<a href="index.html">Back</a>
		</p>
	</body>
</html>
